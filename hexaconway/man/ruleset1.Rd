% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rules.R
\name{ruleset1}
\alias{ruleset1}
\alias{ruleset2}
\alias{ruleset3}
\alias{ruleset4}
\alias{ruleset5}
\alias{ruleset6}
\alias{ruleset7}
\alias{ruleset8}
\title{Sets of Rules}
\usage{
ruleset1(neighnumber, attriMatrix)

ruleset2(neighnumber, attriMatrix)

ruleset3(neighnumber, attriMatrix)

ruleset4(neighnumber, attriMatrix)

ruleset5(neighnumber, attriMatrix)

ruleset6(neighnumber, attriMatrix)

ruleset7(neighnumber, attriMatrix)

ruleset8(neighnumber, attriMatrix)
}
\arguments{
\item{neighnumber}{Matrix where one entry is the sum of the neighbours of the corresponding cell/node.}

\item{attriMatrix}{Matrix with the actual states of the cells.}
}
\value{
Matrix of the freshly computed cell attributes of the new generation.
}
\description{
Implementations of eight sets of rules. These are applied to compute the state of the
cells/nodes of the next generation.
}
\section{Functions}{
\itemize{
\item \code{ruleset1}: 2,3/3

\item \code{ruleset2}: 2/1

\item \code{ruleset3}: parity-rule: disregarding the actual state of the cell \cr
sum(neighbours) mod 2 == 0 -> 1; \cr
sum(neighbours) mod 2 != 0 -> 0)

\item \code{ruleset4}: inverse parity-rule: disregarding the actual state of the cell \cr
sum(neighbours) mod 2 == 0 -> 0; \cr
sum(neighbours) mod 2 != 0 -> 1)

\item \code{ruleset5}: alternative parity-rule: take actual state of the cell into account \cr
sum(neighbours+actual state) mod 2 == 0 -> 1;\cr
sum(neighbours+actual state) mod 2 != 0 -> 0

\item \code{ruleset6}: 3,4/2

\item \code{ruleset7}: 3,5/2

\item \code{ruleset8}: 3/2,4,5 (as said in one blog no GL-rule - but might be interesting)
}}

